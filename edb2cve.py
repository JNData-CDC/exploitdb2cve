#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import re
import argparse
import json
import datetime
from pathlib import Path
from typing import List, Dict


def unique_cves_from_file(file_path: Path) -> List[str]:
    exploit_file_contents = file_path.read_text(encoding="utf-8")
    regex = r"CVE-\d{4}-\d{4,}"
    # quick way to keep it as a list, but make unique
    return list(set(re.compile(regex).findall(exploit_file_contents)))


def get_mapping(exploit_db_path: Path) -> List[Dict]:
    files_exploits = Path(exploit_db_path, "files_exploits.csv")
    if not files_exploits.exists():
        sys.exit("The file 'files_exploits.csv' not found in the specified directory")

    m = []
    # loop through the file, grab the EDBID, parse the target file, and find CVEs in it.
    with open(files_exploits, mode="r", encoding="utf-8") as fe:
        for line in fe.readlines():
            # don't parse header (1st line)
            if not re.compile(r"id,file,description,date,author,type,platform,port").match(line):
                # file format is:
                # id,file,description,date,author,type,platform,port
                # but we just need first 2 columns
                edb_id, exploit_file, _ = line.split(",", maxsplit=2)
                cves = unique_cves_from_file(Path(exploit_db_path, exploit_file))
                if len(cves) > 0:
                    m.append({"id": edb_id, "cves": cves})
    return m


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate mapping: EDBID => CVEs")
    parser.add_argument("exploit_db_path", help="ExploitDB local clone path")
    parser.add_argument("-o", "--output", action="store", dest="output",
                        default="./edbid-to-cve-map.json", help="(json) output file path")
    args = parser.parse_args()

    mapping = get_mapping(Path(args.exploit_db_path))
    now = datetime.datetime.utcnow().isoformat(timespec='seconds')
    doc = {"timestamp": now, "mapping": mapping}
    with open(args.output, "w") as o:
        json.dump(doc, o)
